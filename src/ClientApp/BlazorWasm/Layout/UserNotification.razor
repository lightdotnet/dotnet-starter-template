@using Monolith.Notifications
@using Monolith.Identity
@implements IAsyncDisposable

<MudMenu PositionAtCursor="false" AnchorOrigin="Origin.BottomCenter" TransformOrigin="Origin.TopCenter">
    <ActivatorContent>
        @if (unreadCount > 0)
        {
            <MudBadge Content="@unreadCount" Color="Color.Warning" Overlap="true" Bordered="true" Class="mx-6 my-4 mr-3">
                <MudIconButton
                    Icon="@Icons.Material.Filled.Notifications"
                    Size="Size.Small" Color="Color.Inherit" DropShadow="false" Ripple="false"
                    Class="@($"{animate}")" />
            </MudBadge>
        }
        else
        {
            <MudIconButton
                Icon="@Icons.Material.Filled.Notifications"
                Size="Size.Small" Color="Color.Inherit" DropShadow="false" Ripple="false"
                Class="@($"mx-6 my-4 mr-3 {animate}")" />
        }
    </ActivatorContent>
    <ChildContent>
        @if (notifications != null)
        {
            <div class="noti-list">
                @foreach (var entry in notifications)
                {
                    <div class="noti-card" @onclick="() => ReadEntryAsync(entry)">
                        <div class="text-end">
                            <small>@entry.Created.ToLocalTime().ToString("yyyy-MM-dd HH:mm")</small>
                        </div>
                        <b class="@(entry.ReadStatus ? "" : "text-warning")">@entry.Title</b>
                        <div class="text-wrap text-break">
                            @entry.Message
                        </div>
                        <div class="text-end">
                            <small class="text-end">@entry.FromName</small>
                        </div>
                    </div>
                    <MudDivider />
                }
            </div>
        }
    </ChildContent>
</MudMenu>

@inject SignalRClient SignalR
@inject NotificationHttpService NotificationService
@inject IIdentityManager IdentityManager

@code {
    private int unreadCount = 0;

    private string animate => unreadCount > 0 ? "animated swing infinite" : "";

    private IEnumerable<NotificationDto>? notifications;

    protected override async Task OnInitializedAsync()
    {
        var connected = await SignalR.ConnectAsync();

        if (connected is false)
        {
            return;
        }

        await LoadUserNotificationsAsync();

        SignalR.On<SystemMessage>(async (message) =>
        {
            await LoadUserNotificationsAsync();

            await InvokeAsync(StateHasChanged);

            await JSRuntime.PlayNoti();
        });

        SignalR.On<ForceLogoutMessage>(async (message) =>
        {
            await IdentityManager.LogoutAsync();

            await InvokeAsync(StateHasChanged);
        });
    }

    private async Task LoadUserNotificationsAsync()
    {
        await CountUnreadAsync();
        await LoadNotificationEntries();
    }

    private async Task CountUnreadAsync()
    {
        var currentUserId = CurrentUser.UserId;

        if (string.IsNullOrEmpty(currentUserId))
            return;

        var countUnread = await NotificationService.CountUnreadAsync(currentUserId);

        if (countUnread.Succeeded)
        {
            unreadCount = countUnread.Data;
        }
    }

    private async Task LoadNotificationEntries(bool onlyUnread = false)
    {
        var notificationLookup = new NotificationLookup
        {
            ToUser = CurrentUser.UserId,
            OnlyUnread = onlyUnread,
            PageSize = 10,
        };

        var getEntries = await NotificationService.GetAsync(notificationLookup);

        if (getEntries.Succeeded)
        {
            notifications = getEntries.Data.Records;
        }
    }

    private async Task ReadEntryAsync(NotificationDto notification)
    {
        if (notification.ReadStatus is false)
        {
            await NotificationService.ReadAsync(notification.Id);
        }

        await LoadUserNotificationsAsync();

        if (!string.IsNullOrEmpty(notification.Url))
        {
            NavigationManager.NavigateTo(notification.Url);
        }
    }

    public async ValueTask DisposeAsync()
    {
        await SignalR.DisposeAsync();
    }
}