@using Monolith.Blazor.Infrastructure
@implements IAsyncDisposable

<MudMenu PositionAtCursor="false" AnchorOrigin="Origin.BottomCenter" TransformOrigin="Origin.TopCenter">
    <ActivatorContent>
        @if (unreadCount > 0)
        {
            <MudBadge Content="@unreadCount" Color="Color.Warning" Overlap="true" Bordered="true" Class="mx-6 my-4 mr-3">
                <MudIconButton
                    Icon="@Icons.Material.Filled.Notifications"
                    Size="Size.Small" Color="Color.Inherit" DropShadow="false" Ripple="false"
                    Class="@($"{animate}")" />
            </MudBadge>
        }
        else
        {
            <MudIconButton
                Icon="@Icons.Material.Filled.Notifications"
                Size="Size.Small" Color="Color.Inherit" DropShadow="false" Ripple="false"
                Class="@($"mx-6 my-4 mr-3 {animate}")" />
        }
    </ActivatorContent>
    <ChildContent>
        @if (notifications != null)
        {
            <div class="row m-2">
                <div class="col-6">
                    @if (unreadFilter)
                    {
                        <u><i style="cursor: pointer" @onclick="() => LoadNotificationEntries(false)">View all</i></u>
                    }
                    else
                    {
                        <u><i style="cursor: pointer" @onclick="() => LoadNotificationEntries(true)">View Unread</i></u>
                    }
                </div>
                <div class="col-6 text-end">
                    <u><b><i style="cursor: pointer" @onclick="ReadAllAsync">Read All</i></b></u>
                </div>
            </div>
            <hr />
            <div class="noti-list">
                @foreach (var entry in notifications)
                {
                    <div class="noti-card" @onclick="() => ReadEntryAsync(entry)">
                        <div class="text-end">
                            <small>@entry.Created.ToLocalTime().ToString("yyyy-MM-dd HH:mm")</small>
                        </div>
                        <b class="@(entry.ReadStatus ? "" : "text-warning")">@entry.Title</b>
                        <div class="text-wrap text-break">
                            @entry.Message
                        </div>
                        <div class="text-end">
                            <small class="text-end">@entry.FromName</small>
                        </div>
                    </div>
                    <MudDivider />
                }
            </div>
        }
    </ChildContent>
</MudMenu>

@inject SignalRClient SignalR
@inject UserProfileHttpService UserProfileService
@inject ISignInManager IdentityManager

@code {
    private int unreadCount = 0;

    private string animate => unreadCount > 0 ? "animated swing infinite" : "";

    private IEnumerable<NotificationDto>? notifications;

    private bool unreadFilter = false;

    protected override async Task OnInitializedAsync()
    {
        var connected = await SignalR.ConnectAsync();

        if (connected is false)
        {
            return;
        }

        await LoadUserNotificationsAsync();

        SignalR.On<SystemMessage>(async (message) =>
        {
            await LoadUserNotificationsAsync();

            //await JSRuntime.PlayNoti();
        });

        SignalR.On<ForceLogoutMessage>(async (message) =>
        {
            await IdentityManager.SignOutAsync();

            await InvokeAsync(StateHasChanged);
        });
    }

    private async Task LoadUserNotificationsAsync()
    {
        await CountUnreadAsync();
        await LoadNotificationEntries();

        await InvokeAsync(StateHasChanged);
    }

    private async Task CountUnreadAsync()
    {
        var countUnread = await UserProfileService.CountUnreadNotificationsAsync();

        if (countUnread.Succeeded)
        {
            unreadCount = countUnread.Data;
        }
    }

    private async Task LoadNotificationEntries(bool onlyUnread = false)
    {
        unreadFilter = onlyUnread;
        
        var notificationLookup = new NotificationLookup
        {
            ToUserId = CurrentUser.UserId,
            OnlyUnread = onlyUnread,
            PageSize = 10,
        };

        var getEntries = await UserProfileService.GetNotificationsAsync(notificationLookup);

        if (getEntries.Succeeded)
        {
            notifications = getEntries.Data.Records;
        }
    }

    private async Task ReadEntryAsync(NotificationDto notification)
    {
        if (notification.ReadStatus is false)
        {
            await UserProfileService.ReadNotificationAsync(notification.Id);
        }

        await LoadUserNotificationsAsync();

        if (!string.IsNullOrEmpty(notification.Url))
        {
            NavigationManager.NavigateTo(notification.Url);
        }
    }

    private async Task ReadAllAsync()
    {
        await UserProfileService.ReadNotificationAsync("all");

        await LoadUserNotificationsAsync();
    }

    public async ValueTask DisposeAsync()
    {
        await SignalR.DisposeAsync();
    }
}